module Techdraw.Internal.Fuzzer exposing
    ( Range(..)
    , TestTransform(..)
    , genPt, genPtRange
    , genHPt, genHPtRange
    , genAffineMatrix, genAffineMatrixTestTransforms, applyTestTransforms, toAffineMatrix
    )

{-| Testing fuzzers for this package.


# Types

@docs Range
@docs TestTransform


# Fuzzers


## Points

@docs genPt, genPtRange
@docs genHPt, genHPtRange


## Affine matrices

@docs genAffineMatrix, genAffineMatrixTestTransforms, applyTestTransforms, toAffineMatrix

-}

import Fuzz exposing (Fuzzer, floatRange, listOfLengthBetween, oneOf)
import List
import Techdraw.Internal.AffineMatrix as AffineMatrix exposing (AffineMatrix)



---- Points --------------------------------------------------------------------------------------


{-| Range of floating-point values.
-}
type Range
    = Range
        { min : Float
        , max : Float
        }


genFloatRange : Range -> Fuzzer Float
genFloatRange (Range r) =
    Fuzz.floatRange r.min r.max


{-| Generate a point in a default range.
-}
genPt : Fuzzer ( Float, Float )
genPt =
    genPtRange (Range { min = -5000, max = 5000 })


{-| Generate a point with components in a given range.
-}
genPtRange : Range -> Fuzzer ( Float, Float )
genPtRange r =
    let
        genF =
            genFloatRange r
    in
    Fuzz.map2 (\x y -> ( x, y )) genF genF


{-| Generate a homogeneous (3-component) point with components in a default range.
-}
genHPt : Fuzzer ( Float, Float, Float )
genHPt =
    genHPtRange (Range { min = -5000, max = 5000 }) (Range { min = 0, max = 1 })


{-| Generate a homogeneous (3-component) point with components in a given range.
-}
genHPtRange : Range -> Range -> Fuzzer ( Float, Float, Float )
genHPtRange rxy rw =
    let
        genF =
            genFloatRange rxy
    in
    Fuzz.map3 (\x y w -> ( x, y, w )) genF genF (genFloatRange rw)



---- Matrices -------------------------------------------------------------------------------------


{-| Generate an affine matrix.

An affine matrix is generated by multiplying together random matrices describing translation,
scale and rotation.

-}
genAffineMatrix : Fuzzer AffineMatrix
genAffineMatrix =
    Fuzz.map (\( m, _ ) -> m) genAffineMatrixTestTransforms


{-| Generate an affine matrix and a list of corresponding transformations.

An affine matrix is generated by multiplying together random matrices describing translation,
scale and rotation.

-}
genAffineMatrixTestTransforms : Fuzzer ( AffineMatrix, List TestTransform )
genAffineMatrixTestTransforms =
    Fuzz.map
        (\tts ->
            let
                mats =
                    List.map toAffineMatrix tts

                mat =
                    List.foldr
                        (\m1 m2 -> AffineMatrix.mul m2 m1)
                        AffineMatrix.identity
                        mats
            in
            ( mat, tts )
        )
        (listOfLengthBetween 1 10 genTestTransform)


{-| Individual parts of test transformations.
-}
type TestTransform
    = Translate { tx : Float, ty : Float }
    | Scale { sx : Float, sy : Float }
    | Rotate { radians : Float }


applyTestTransform : TestTransform -> ( Float, Float ) -> ( Float, Float )
applyTestTransform tt ( px, py ) =
    case tt of
        Translate t ->
            ( px + t.tx, py + t.ty )

        Scale s ->
            ( px * s.sx, py * s.sy )

        Rotate r ->
            let
                s =
                    sin r.radians

                c =
                    cos r.radians
            in
            ( c * px - s * py, s * px + c * py )


{-| Apply a list of test transformations to a point.
-}
applyTestTransforms : List TestTransform -> ( Float, Float ) -> ( Float, Float )
applyTestTransforms tts pt =
    List.foldl applyTestTransform pt tts


{-| Convert a test transform to an affine matrix.
-}
toAffineMatrix : TestTransform -> AffineMatrix
toAffineMatrix tt =
    case tt of
        Translate obj ->
            AffineMatrix.translation ( obj.tx, obj.ty )

        Scale obj ->
            AffineMatrix.scaling ( obj.sx, obj.sy )

        Rotate obj ->
            AffineMatrix.rotationRadians obj.radians


genTranslate : Fuzzer TestTransform
genTranslate =
    Fuzz.map (\( tx, ty ) -> Translate { tx = tx, ty = ty }) genPt


genScale : Fuzzer TestTransform
genScale =
    Fuzz.map2
        (\sx sy -> Scale { sx = sx, sy = sy })
        (floatRange 0.1 10.0)
        (floatRange 0.1 10.0)


genRotate : Fuzzer TestTransform
genRotate =
    Fuzz.map
        (\radians -> Rotate { radians = radians })
        (floatRange (-3 * pi) (3 * pi))


genTestTransform : Fuzzer TestTransform
genTestTransform =
    oneOf [ genTranslate, genScale, genRotate ]
